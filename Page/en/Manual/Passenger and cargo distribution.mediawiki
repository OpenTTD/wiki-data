[[Translation:en/Manual/Passenger and cargo distribution]]


{{en/Warning|Savegames which are created with this branch might no longer work in subsequent versions. They will for sure not work in trunk, even if Cargodist is ever merged into trunk.}}

So this is the (n+1)th attempt to provide passengers and freight with destinations and then getting them there using the existing transport links as efficiently as possible. Further details on the problem can be found [[en/Community/Patches/Passenger and cargo destinations|here]]. However, in contrast to the cargod'''e'''st project the problems of routing cargo and balancing loads on different routes are seen as inseperable here and thus solved together. Also the definition of transportation demand is seen as precondition to solving above problems and handled first. The main differences to YACD are that Cargodist a, only considers reachable destinations, not the whole map and b, precomputes the whole routing scheme in separate threads for performance reasons.

The [http://www.tt-forums.net/viewtopic.php?f=33&t=41992&start=0 main forum topic] has some more information.

The openttd compile farm builds binaries of cargodist for various platforms every night. You can download them at http://bundles.openttdcoop.org/cargodist/.

You can also pull from my git tree. It's located at git://github.com/fonsinchen/openttd-cargodist.git and the relevant branch is "cd". So if you want the latest version of everything, do:

 git clone git://github.com/fonsinchen/openttd-cargodist.git
 git checkout origin/cd

The "cd" branch is frequently rebased on trunk and contains the following milestones, conveniently arranged as commits:

==Tracking capacities, usages and supplies==

The transport capacity of the link between station A and station B is the sum of the capacities of all vehicles arriving at B and coming from A. The usage of the link is the number of goods actually transported from A to B. The supply is the amount of cargo generated at a station. These numbers are calculated per cargo type and in order to not let them grow infinitely a moving average is taken over a configurable time. The moving average is calculated differently for supply on the one hand and capacity and usage on the other. Capacity and usage are scaled linearly when dropping below the moving average length. This helps cleaning up stale links. To compensate, capacity and usage get a boost when being increased from a small base value. Like this small but regular increases to capacities and usages don't lead to loss of links.

==Link graph and connected components==

The nodes in the graph are partitioned into connected components. This isn't very useful on its own, but will be needed for further steps. The computation of connected components doesn't work if there are a lot of vehicles that visit a station and never come back to that station. This behaviour has been shown by certain AIs, but fixing isn't a high priority. You get a new settings page here: ''linkgraph''. Every time a connected component is calculated a copy of these settings is made for this component. These copies are saved and loaded. Later on a seperate thread will be created for the calculation of each component and the settings at the time of the creation will be carried around. Like this all settings can be changed during the game and the threading model stays network-safe. The first entry in the link graph settings is ''recalculation interval''. This is the time between subsequent recalculations of the link graph. If you increase it, it will take less CPU power. If you decrease it, the cargodist algorithm will run more often, resulting in a more accurate routing if your routes change often.

==Transport demand==

A demand function defines how many units of cargo '''should''' be transported between certain nodes in the link graph. It doesn't say how many units of cargo are actually transported, nor how they are transported. Actually at least two such functions are needed. Certain cargos, passengers and mail mostly, require a symmetric demand function, others a roughly antisymmetric one.

===Symmetric and antisymmetric demand===

The symmetric function should have the following property:

  for all pairs of nodes (i, j): demand(i, j) == demand(j, i)

The antisymmetric one should have the following property instead:

  for all pairs of nodes (i, j): demand(i, j) > 0 => demand(j, i) == 0

In practice it is convenient to have a semi-symmetric function which is modifiable by a configuration option ''0 <= k <=1'' like this:

  for all pairs of nodes (i, j): demand(i, j) >= k * demand(j, i) >= k * k * demand(i, j) || demand(j, i) >= k * demand(i, j) >= k * k * demand(j, i)

For ''k == 0'' this is the antisymmetric function and for ''k == 1'' it's the symmetric function.

Furthermore the distance between the nodes should play a role in the demand calculation and the sum of all ''demand(i, j)'' cannot be higher than ''supply(i)'' for any node ''i''.
Thus the algorithm implementing the demand function generates a list of nodes supplying cargo and another one of nodes accepting cargo. It then repeatedly loops over all pairs of nodes ''(from, to)'' where ''from'' supplies and ''to'' accepts. For each such pair it assigns a fraction of the supply at ''from'' as ''demand'' between ''from'' and ''to'' until no supply is left at any station. Provided that ''k > 0'' it also assignes ''demand * k'' in the other direction if there is enough supply at ''to'' and ''from'' also accepts. Otherwise less or no demand is generated in the forward direction. The size of the assigned fraction depends on:

* The manhattan ''distance'' between the nodes. 
* An ''accuracy'' configuration setting. The higher the accuracy the less demand is generated each round.

Generally the formula is ''maxDistance / (maxDistance - distance) / accuracy'' where maxDistance is the the sum of the x- and y-dimensions of the map.

===Acceptance-based demand===

As a third option there could be a function that takes the quantity of acceptance (intentionally not called ''demand'' here) of stations into account. Implementation would be analog to the symmetric and antisymmetric demand functions, but the quantities of acceptance would need to be known. One way to determine them could be a measurement of consumed goods at the station, just like the supply is a measurement of generated goods at a station.

===Configuration and save/load===

You can change which function is used for which cargo class in the link graph settings. Additionally there is an entry ''unhandled'' which will result in no demands being calculated. The influences of station size (''k'', only for symmetric) and distance (''l'') as well as the accuracy can also be set in the link graph settings. The calculation of the demands (as well as later parts of the algorimth) takes place per connected component and in a seperate thread for each component. The threads all work on their own data and are joined with the main thread after defined intervals for copying the results. When saving the starting state, joining time and link graph settings of each running thread are saved. Like this the threads can be started in a valid state when loading a game or joining a network game.

==Multi-commodity flow problem==

With the demands and capacities known a [http://en.wikipedia.org/wiki/Multi_commodity_flow multi commodity flow] problem is defined. To solve it an algorithm inspired by [http://www.cs.princeton.edu/~gk/papers/mincostflow.ps this one] is used. The link graph setting for the desired accuracy of the solution is reused here. The more accurate you want the solution the heavier the toll on your CPU.

The algorithm repeatedly calculates the best paths from any node to any other in the component it is working on and adds to every path a flow of 1/accuracy of the unsatisfied demand between the path's source and destination nodes. Best paths are calculated using [http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm Dijkstra's algorithm]. The MCF solver is split in two passes.

In the first pass the quality of an edge is measured as the the manhattan distances between the stations involved. The algorithm will only assign flows to paths with capacity left. This means first all shortest paths are saturated, then increasingly longer paths and so on until either no demand is left or the capacities of all useful paths are used up to a maximum percentage. The maximum percentage can be configured with the "short path saturation" link graph setting. After running into this situation all cycles in the graph are eliminated. This is done by checking for each node via depth-first-search if the paths departing from this node form a tree and otherwise reducing the detected cycles until at least one edge's flow is 0. If any cycles have been eliminated the first pass is started again as the freed capacity could allow for more paths.

The second pass is run if demand is left after the first pass, but no capacity. In the second pass quality is measured as the difference between the capacity of an edge and the flow already assigned to it. The algorithm is allowed to oversaturate edges and assign more flow than capacity. Yet it may only assign additional flow to paths that have already been established by the first pass. The second pass is run until there is no more demand left. 

Because of the explicit cycle check of the first pass and the fact that the second pass doesn't add any new paths the MCF solver cannot build cyclic paths. Assigning all available demand is necessary in order to guarantee that cargo is actually sent where the demand calculator has determined it to go and not only to the destinations connected by the best paths.

==Flow mapping core functionality==

The solution of the multi commodity flow problem is a set of flows along the edges of the link graph. These flows have to be translated into assignments of goods to vehicles. In order to do that at each node a flow mapping is created. An example for a flow mapping could be:

For 15 cargo arriving at A from SOURCE do:
* deliver 5 to this station.
* send 7 to C
* send 3 to D

The actual numbers are deduced from the supplies and the relative sizes of the different flows passing a node. In addition to those ''planned'' flows, the ''real'' flows are tracked. In the example above the amount of cargo originating from SOURCE that has been sent to C or D or consumed locally is tracked as ''real'' flow. When a new cargo packet from SOURCE shows up it is sent to the destination with the greatest difference between real and planned flow. Like this it is not necessary to determine the destination for each cargo entity in advance. Only the flow mappings for each node need to be known in order to route cargo. It is also never necessary to split packets for cargodist reasons. For the real flows again a moving average is taken, like for the capacities and usages.

[[File:en/Manual/Cargodist-station.png|frame|Screenshot of station GUI]]

The assignment of flow is calculated for each station from the path forest the MCF algorithm returns. This is rather easy. Simply scale all paths by the supply of the origin station and insert them into a clever data structure that retrieves the most underprovisioned flow in constant time.

==Vehicle loading==
'''Preface: Go to "Advanced Settings -> Vehicles" and switch on "New orders are non-stop by default". If you want to know why, read on.'''

This part includes loading and unloading vehicles according to the flows calculated above. It was unavoidable to rewrite much of the vehicle loading code, so there might still be bugs in it. Yet, this solution is easier to read, reuse and debug than the previous one, so the rewrite should pay for itself eventually.

A cargo packet unloaded at a station selects its next hop according to the flow for its origin saved at the station. When a vehicle loads at a station it will generally only take cargo wanting to go to the next ''real stop'' in its order list. A ''real stop'' is any stop at a station where a vehicle can load or unload. This means servicing, buoys or other ''via'' orders where the vehicles has no chance of loading or unloading are excluded.

Nondeterministic orders are handled by falling back to traditional routing. A nondeterministic order is either an order without the ''non-stop'' flag or a conditional order where the next ''real stop'' can evaluate to at least two different stations. Mind that for example skipping a servicing order if the vehicle doesn't need servicing is thus not a nondeterministic order. However, choosing the next station according to the load percentage of the vehicle is. If a nondeterministic next order is encountered the vehicle will load any cargo available at the station, without caring for destinations.

Cargo not handled by cargodist is also routed traditionally. Cargo wanting to go over a nonexistant link is rerouted according to the other flows for its source station. The latter case is detected when deleting link statistics.

Order modifications such as "no unloading", "unload all", "transfer", "no loading", etc generally do what they are supposed to when using cargo distribution. However, as the link graph doesn't know about orders it assumes it can use any link with a capacity. It will thus also plan cargo to be sent with those vehicles that decline loading cargo. In the same way it will plan cargo to be transferred at a station where you force cargo to be delivered. This means you artificially change the ratios between sent and planned cargo on those links, which will make the flow mapping assign even more cargo to the links you are trying to avoid. It is thus suggested to not use order modifications together with cargo distribution. This excludes "full load", which is the only order modification that doesn't have any bad effects on the flow mapping.

==Station GUI==
The station GUI shows the sources, next hops and estimated destinations of the cargo waiting as well as those of the planned and sent cargo flows through this node. Final destinations are estimated according to the flows saved at each station. Don't expect each packet of cargo to go exactly that way, though. As explained above, packets are always routed without splitting them, so the numbers given in the station GUI are always a little incorrect, but in the long run everything is still sent to their proper destinations. You can group the cargo by source station, next hop and destination in any order. Also you can sort within the groups by the property you group by (''station'') or the amount of cargo displayed (''amount''). Groups can be opened and collapsed by clicking on the respective lines in the cargo display.

==Smallmap Zoom In==
[[File:fr/Manual/Cargodist-smallmap-flow.png|frame|Screenshot of smallmap with flows]]
In order to increase the readability of the statistics display in the smallmap a zoom in function has been added. Using it you can not only zoom out for overview in the smallmap, but also zoom in to get a more detailed display of the link statistics, for example in a town center.

==Smallmap Stats==
In the smallmap the planned and real flows over each link are shown. You can choose which stats you should be shown by enabling or disabling the respective buttons in the legend. Usage and capacity are like above, real flow and planned flow are new. Real flow is the amount of cargo already sent along the link. The difference between usage and real flow is the amount of cargo which has been assigned the remote end of the link as next hop, but hasn't necessarily arrived there yet. If the usage is considerable larger than the real flow, cargo has been sent along the link unexpectedly. This can happen if there are problems predicting the flow of cargo due to order modifications. 

You can either have the stats shown in numbers (units of cargo per month) or as graphs. If shown as numbers the numbers in the map are in the same order as the legend entries.

==External Station Ratings==
tbd

==Optimizations==
The vehicle loading described above proved to be very slow when using the stock OpenTTD cargo lists. This is mainly because in order to find packets that could be loaded into vehicles the list has to be searched linearly for packets with the same next hop as the loading vehicle. With a lot of cargo waiting this can take a lot of time. As a second problem the cargo reserved for loading vehicles couldn't be saved as a simple number anymore because a vehicle couldn't load just any packet anymore. In order to make reservations work again specific packets had to be reserved for specific vehicles. Rebuilding those lists of reserved packets in each loading round is costly. To resolve these problems two optimizations have been introduced.

===Station Cargolists sorted by next hop===
Station cargo lists are sorted by the next hop a packet wants to travel to. Like this a loading vehicle doesn't have to search all packets in the list for loadable ones but can directly refer to the section of the list where packets travelling to its next stop reside. As an added benefit the next hop doesn't have to be saved inside the packet anymore but can be inferred from its index in the packet map. To make this work a multimap with some additional guarantees had to be designed. The order of entries with equal keys needs to be the same on all platforms in order to avoid desyncs. Unfortunately the standard C++ multimap doesn't guarantee this.

===Explicit Reservation===
Instead of rebuilding the reservation list in each loading round reserved cargo is kept in a seperate list inside the vehicle cargo list. Like this the amount of cargo to be searched in each loading round is reduced and the effort of rebuilding the reservations is spared. Reservation lists are saved in the savegames along with the normal vehicle cargo lists.

fonsinchen 22:39, 4 March 2010 (UTC)