[[Translation:en/Community/Railway Designs]]
{{fr/Traduction|en/Community/Railway Designs|40}}
{{fr/Manual/Table des matières}}

=Capacité de transport de votre réseau=
Avant d'aller plus avant, considérez que cette page traite de la capacité de transport du réseau de façon purement théorique. Les jonctions et l'organisation du réseau sont bien plus importants. Fin de la mise en garde. Considérons maintenant les différents facteurs qui affectent votre capacité de transport.

==Distance inter-signaux (DIS)==
[[File:en/Community/Pat Fig1.png|thumb|left|Figure 1: Espace minimum entre deux trains de 5 cases pour une DIS de 4]]
C'est un paramètre relativement évident. Des signaux très espacés vont réduire la capacité de transport. Avec une '''DIS''' de un signal toutes les n cases, l'espace entre deux trains à vitesse maximum ne sera jamais en dessous de n+1 cases (Figure 1). Quand les trains sont tous aussi proches l'un de l'autre, vous avez atteint la densité de trains. En pratique, atteindre cette densité est impossible.<br style="clear:both;">

===Donc quelle ''DIS'' devrais-je choisir ?===
====La loi de l'écart maximum====
[[File:en/Community/Pat Fig2.png|frame|right|Figure 2 : Inefficacité due à l'écart de signalisation]]
Quelle que soit la '''DIS''' que vous choisissiez, une considération importante à prendre en compte est la consistance. La capacité d'une voie est déterminée par l'écart de signaux le plus important. Ainsi, une voie avec un signal toutes les deux cases, qui a une anomalie de trois ou quatre cases entre deux signaux, souffrira d'une capacité grandement diminuée et pourra subir des embouteillages et violer la règle n<sup>o</sup>1 (Figure 2). Il est à noter que les signaux ne peuvent être placés sur des jonctions, des ponts ou des tunnels. Ainsi il est inutile de faire un écart de 1 si la voie est séparée par un pont de 12 cases.<br style="clear:both;">

====Les voies diagonales====
[[File:en/Community/Tiles.png|frame|right|Figure 3 : en bas, on voit que l'écart de 1 case est plus important sur les voies obliques que sur les voies parallèles. Sur la voie du haut, le nombre de signaux a été doublé afin de palier ce problème.]]
Comme vous l'avez remarqué, les voies sont posées sur des cases carrés. Par défaut le moteur de jeu considère qu'un écart d'une case, dans une voie oblique, correspond à la diagonale d'une case. Ainsi dans le moteur d'openttd, les trains se déplacent plus lentement, en terme de case, sur les voies obliques (merci SmatZ !). Donc il faut soit augmenter la densité de signaux sur les voies diagonales (on peut placer un signal toutes les demi cases), soit considérer que l'écart sur une voie diagonale est l'écart maximum. Par exemple, pour un écart de 1, le rapport d'écart inter-signaux pour une voie diagonale par rapport à une voie parallèle sera d'environ 1,41 (en utilisant le théorème de Pythagore)<br style="clear:both;">

==Longueurs des trains (LT)==
C'est une épée à double tranchant. Un train plus long augmentera la probabilité de subir une pénalité d'accélaration réaliste, rendant ainsi les constructions plus étendues et complexes. Cependant, un train plus long augmente la capaicté maximum de cargaison de votre réseau. Notez qu'en utilisant des moteurs répartis en tête et queue de train, la demi-case de perdue réduit encore la faible capacité des trains courts. 

Les valeurs typiques sont de trois à cinq cases, quatre étant particulièrement idéal dans les réseaux à grande vitesse.

{{fr/Attente de traduction}}

==Quantifier la capacité de transport==
===Densité de Trains (DT)===
Votre réseau va supporter un certain nombre de trains, et en partant du principe que vous avez une longueur de trains journalisés, on peut définir certaines mesures. La '''Densité de Trains (DT)''' pour une voie est donée en unités ''trains par miller de cases'' et peut être calculé en contant le nombre de trains sur la voies divisés par la longueur de la voie.

Typical measured values for an unoptimised network of 4-tile trains are a '''TD''' of 25 (trains per 1000 tiles).

The maximum '''TD''' before traffic jams become self-propagating can be measured by permitting a queue of trains to accelerate from a halt and then measuring the train-train distance when all trains have reached full speed, and using the formula 

'''1000 / (TL + train gap)'''

For example, a fully-laden 4-tile [[en/Manual/Base Set/Trains/Lev4 'Chimaera'|Chimaera]] (top-end [[en/Manual/Base Set/MagLev]]) was found to have a train-train distance of 12, giving critical density of 1000/16 or 62.5.

Because this critical density incorporates information about acceleration and time to reach top speed, it can also tell you about the practical capacity of your network. For example, using trains with a lower top speed actually makes it easier to have a dense network. The average train-train gap is much smaller for rail than for monorail or maglev. Repeating the previous example but using the electric rail T.I.M gives a train-train distance of only 6, and a critical density of 100. Slow doesn't mean better, however, as the reduced line density will be more than compensated for by quick turnaround times.

It is possible to run a network at higher than the critical density, but it is ill-advised.

===Theoretical Maximum Train Density===
Simply put, this is the train density if your network is entirely filled with trains at the minimum distance between each other. You will never reach this. 

This is given by ''' 1000 / (TL + SD + 1) '''

For example, 4-tile trains and a signal distance of 2 will give a theoretical maximum train density of 140.

==Carrying Capacity (CC)==
Since '''TL''' alters the carrying capacity of a line, comparing '''TD''' across different '''TL''' is meaningless. In order to compare efficiency figures between different personal preferences, we need a new metric. This new metric will simply be a measure of how many units of cargo your network is transporting per year, per track. It will be directly proportional to the average quantity of cargo per track tile, and also to how fast this cargo is moving.

Work on this unit is pending.

=Making your network more efficient=
Ok, so now that we've defined the parameters that we had already intuitively understood, how can we use them to improve our networks? The golden rule of network optimisation is that trains on the network never slow down. There are two possible parts of a network where this could happen, splits and merges.

==Splits==
For a track split, one must ensure that there is not a longer-than-normal signalling gap at the split point. This can be taken care of by careful or over-abundant signalling.

==Merges==
Merges present us with a unique problem. For a trivial merge, trains on the mainline could potentially be stopped by a sideline train. There is already a body of work on [http://www.openttdcoop.org/wiki/Priorities Priorities] by our colleagues in the cooperative circuit. A perusal of this link should familiarise you with the principles of priority merges.

Consider a typical non-junction merge, at the exit of a pickup station. A tightly-packed optimised stream of trains enters the station, but because of differences in loading times, this order is disrupted on the station exit, and you end up with two tracks of loosely-packed trains. One of these lines, designated the main line, will have, on average, train-train gaps large enough to fit a third train into. Simply connecting the two lines together will not work, and a priority merge is required.

[[File:en/Community/Diamond Stream.png|thumb|right|Figure 3: Dropoff with stream reassembly]]
Note that, because trains that drop off cargo always spend the same length of time at a platform, it is possible to dematerialise and reassemble a tightly packed stream of trains, even one above the critical density! (Figure 3).<br style="clear:both;">

[[File:en/Community/Priority Merge.png|thumb|right|Figure 4: Priority merge]] A first-pass merge using a priority block will reduce the traffic ratio from 1:1 to about 3:1 in favour of the main track (Figure 4). Adding a second priority merge straight after the first one would be a futile gesture, since trains on both lines would continue at the same speed and the mainline train would simply claim priority again. Introducing a delay by a loop of track, followed by a second priority merge, will reduce the sideline to a mere trickle of trains and will have filled in most of the available slots on the mainline. Existing solutions would involve a pre-acceleration track, however a cyclotron eliminates the need to lose momentum.<br style="clear:both;">

===Cyclotrons===
Consider a sideline that loops back on itself after a failed priority merge. A train in this loop would continue to re-test the mainline for entry conditions, once every 8 * '''TL'' tiles until it found a space large enough to merge with the main line. After the cyclotron was empty, the next waiting train could pre-accelerate and be injected into the cyclotron, ready to continue the cycle. This system has some flaws, however, as it has a capacity of one train and there will be many missed opportunities due to the train being in the wrong position in the accelerator. The design is pictured [[:File:en/Community/Simple Cyclotron.png|here]] for reference. Junctions are a large and well-trodden area of openttd; I have restricted myself to unbranched feeder structures. You will find that a highly-optimised stream of trains does NOT weather a junction well.

Refinements to the cyclotron are possible. There is enough space on the track loop to contain two trains, and a system of priority signals will enable a second train to optionally enter the cyclotron. With two trains in the cyclotron, there will be a doubled chance of entering a slot on the mainline. In order to prevent a traffic jam inside the cyclotron (which would be disasterous), some delay tweaking is necessary, but the end result is exceedingly useful.

The injection delay assumes that the second injected train is accelerating from standstill, and there is a small chance that second train has in fact chanced upon the cyclotron entrance at full speed. In this case, the timing will be wrong and the second train will almost certainly cause a jam within the cyclotron (and consequently on the main line). This can be compensated for by some additional signalling to filter out full-speed trains. The filtered out full-speed trains can either be diverted onto a second loop, or simply drained of momentum by a signal. 

[[File:en/Community/Junctionary/Cyclotron Full.png|thumb|Figure 5: full-featured cyclotron]]
A cyclotron incorporating all the optimisations discussed, and some additional fixes, is shown in Figure 5.

A savegame containing all of the techniques discussed above is available [http://patrickthomson.ath.cx/cyclotron.sav Here] (version 0.7 or higher required to open).<br style="clear:both;">

Editor's note: Whilst I would like to defend my cyclotron refinements, experimentation has proven that pre-acceleration is a more robust system. The two have been combined in the savegame linked previously.
{{fr/Disponibilité|0.7}}

===Parallel cyclotrons===
An attempt to minimize the drawbacks of the full featured cyclotron leads to parallel, small, 1-train cyclotrons. In this design, an array of cyclotrons, each handling one train, may be fed simultaneously. They may have different loop size in order to prevent synchronization between the cycling trains, giving more chance to find a slot in the flow of the main line. Each loop still needs it own acceleration lane so the trains enter the loop at full speed. If a train happened to enter the loop at low speed, it would get a chance to join the main line at non-max speed and cause a possibly large traffic jam.

[[File:en/Community/Junctionary/Parallel Cyclotron.png|thumb|Figure 6: Parallel cyclotron]]
Figure 6 shows a parallel cyclotron with two loops.

A savegame with the example given in Figure 6 is available [http://gbizzotto.free.fr/parallel_cyclotron.sav Here] (version 0.7 or higher required to open).

Advantages over the full featured cyclotron:
* Can handle more than two trains
* Faster fail-and-retry pace
* No need to synchronize the looping trains
* Easier to build and remember

Drawbacks:
* Bigger when using more than one loop